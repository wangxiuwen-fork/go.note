1.1  用Go解决现代编程难题

1.1.1  开发速度

1.1.2  并发

1．goroutine

Go 语言运行时  会自动在配置的一组逻辑处理器上调度执行 goroutine

每个逻辑处 理器绑定到一个操作系统线程上（见图 1-2）    

图 1-2: 在单一系统线程上执行多个 goroutine  



![图1-2 在单一系统线程上执行多个goroutine.jpg](images\图1-2 在单一系统线程上执行多个goroutine.jpg)

2．通道

通道是一种数据结构，可以让 goroutine 之间进行安全的数据通信  

* 保证并发修改时的数据安全  :

通道这一模 式保证同一时刻只会有一个 goroutine 修改数据  



1.1.3  Go语言的类型系统

* Go 开发者使用组合（composition）设计模式  

在 Go 语言中，一个类型由其他更微小的类型组合而成，避免了传统的基于 继承的模型。  

* 独特的接口机制，允许用户对行为进行建模  ，而不是对类型进行 建模。  

在 Go 语言中，不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否 符合正在使用的接口  

1．类型简单

**传统语言使用继承来扩展结构——Client 继承自 User， User 继承自 Entity， Go 语言与此不同， Go 开发者构建更小的类型——Customer 和 Admin，然后把这些小类型组合成更大的类型。图 1-4 展示了继承和组合之间的不同。  **

2．Go接口对一组行为建模

![图1-4继承和组合的对比.jpg](images\图1-4继承和组合的对比.jpg)



下面是一个 Java 接口的例子：

```java
interface User {
public void login();
public void logout();
}
```

Java 继承 ，严格的面向对象语言  ，所有的设计都围绕接口展开  。在 Java 中要实现这个接口，要求用户的类必须满足 User 接口里的所有约束，并且显式声 明这个类实现了这个接口。  

。而 Go 语言的接口一般只会描述一个单一的动作。  

在 Go 语言中，如果一个类型实现了一个接口的所有方法，那么这个类型的实 例就可以存储在这个接口类型的实例中，不需要额外声明。  



在 Go 语言中，最 常使用的接口之一是 io.Reader。这个接口提供了一个简单的方法，用来声明一个类型有数据 可以读取。  

```go
//io.Reader 接口
type Reader interface {
  Read(p []byte) (n int, err error) 
}  
```

为了实现 io.Reader 这个接口，你只需要实现一个 Read 方法，这个方法接受一个 byte 切片，返回一个整数和可能出现的错误。 这和传统的面向对象编程语言的接口系统有本质的区别。

 Go 语言的接口更小，只倾向于 定义一个单一的动作。实际使用中，这更有利于使用组合来复用代码。用户几乎可以给所有包 含数据的类型实现 io.Reader 接口，然后把这个类型的实例传给任意一个知道如何读取 io.Reader 的 Go 函数。  

Go 语言的整个网络库都使用了 io.Reader 接口，这样可以将程序的功能和不同网络的 实现分离。这样的接口用起来有趣、优雅且自由。文件、缓冲区、套接字以及其他的数据源 都实现了 io.Reader 接口。使用同一个接口，可以高效地操作数据，而不用考虑到底数据 来自哪里。  





1.1.4  内存管理

Go 语言还自带垃圾回收器，不需要用户自己管理内存  



1.2  你好，Go.

介绍 Go Playground  ：允许在浏览器里编辑并运行 Go 语言代码  

http://play.golang.org  

1.3  小结