[TOC]

#第 4 章 数组、切片和映射 53



程序：需要存储和读取集合数据

使用数据库或者文件， 或者访问网络，总需要一种方法来处理接收和发送的数据  

Go 语言有 **3 种数据结构**可以让用户 管理集合数据：**数组、切片和映射**。这 3 种数据结构是语言核心的一部分，在标准库里被广泛使 用。一旦学会如何使用这些数据结构，用 Go 语言编写程序会变得快速、有趣且十分灵活。  



##4.1 数组的内部实现和基础功能 53

了解这些数据结构，一般会从数组开始，因为  数组是切片和映射的基础数据结构  	



###4.1.1 内部实现 53

数组占用的内存是连续分配的  

![图4-1数组的内部实现](images\图4-1数组的内部实现.jpg)

###4.1.2 声明和初始化 54

```go
// 声明一个包含 5 个元素的整型数组
var array [5]int
```

在 Go 语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。  

![图 4-2 声明数组变量后数组的值](images\图 4-2 声明数组变量后数组的值.jpg)



```go
代码清单 4-2 使用数组字面量声明数组
// 声明一个包含 5 个元素的整型数组
// 用具体值初始化每个元素
array := [5]int{10, 20, 30, 40, 50}+
如果使用...替代数组的长度， Go 语言会根据初始化时数组元素的数量来确定该数组的长
度，如代码清单 4-3 所示。
代码清单 4-3 让 Go 自动计算声明数组的长度
// 声明一个整型数组
// 用具体值初始化每个元素+
// 容量由初始化值的数量决定
array := [...]int{10, 20, 30, 40, 50}
如果知道数组的长度而是准备给每个值都指定具体值，就可以使用代码清单 4-4 所示的这种
语法。
代码清单 4-4 声明数组并指定特定元素的值
// 声明一个有 5 个元素的数组
// 用具体值初始化索引为 1 和 2 的元素
// 其余元素保持零值
array := [5]int{1: 10, 2: 20}
```

![图4-3 声明之后的数组的值](images\图4-3 声明之后的数组的值.jpg)

###4.1.3 使用数组 55

```go
代码清单 4-5 访问数组元素
// 声明一个包含 5 个元素的整型数组
// 用具体值初始为每个元素
array := [5]int{10, 20, 30, 40, 50}
// 修改索引为 2 的元素的值
array[2] = 35

代码清单 4-6 访问指针数组的元素
// 声明包含 5 个元素的指向整数的数组
// 用整型指针初始化索引为 0 和 1 的数组元素
array := [5]*int{0: new(int), 1: new(int)}
// 为索引为 0 和 1 的元素赋值
*array[0] = 10
*array[1] = 20
代码清单 4-6 中声明的数组的值在操作完毕后，会和图 4-5 所展现的一样。
```

![图 4-5 指向整数的指针数组](images\图 4-5 指向整数的指针数组.jpg)

在 Go 语言里，数组是一个值。这意味着数组可以用在赋值操作中。变量名代表整个数组 因此，同样类型的数组可以赋值给另一个数组，如代码清单 4-7 所示  

```go
// 声明第一个包含 5 个元素的字符串数组
var array1 [5]string
// 声明第二个包含 5 个元素的字符串数组
// 用颜色初始化数组
array2 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"}
// 把 array2 的值复制到 array1
array1 = array2
复制之后，两个数组的值完全一样，如图 4-6 所示。
```



![图 4-6 复制之后的两个数组  ](images\图 4-6 复制之后的两个数组.jpg)

数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相  同的数组，才能互相赋值，如代码清单 4-8 所示。  



复制数组指针，只会复制指针的值，而不会复制指针所指向的值，如代码清单 4-9 所示  

```go
// 声明第一个包含 3 个元素的指向字符串的指针数
var array1 [3]*string
// 声明第二个包含 3 个元素的指向字符串的指针数组
// 使用字符串指针初始化这个数组
array2 := [3]*string{new(string), new(string), new(string)}
// 使用颜色为每个元素赋值
*array2[0] = "Red"
*array2[1] = "Blue"
*array2[2] = "Green"
// 将 array2 复制给 array1
array1 = array2
复制之后，两个数组指向同一组字符串，如图 4-7 所示。
```

![图 4-7 两组指向同样字符串的数组  ](images\图 4-7 两组指向同样字符串的数组.jpg)



###4.1.4 多维数组 58

```go
代码清单 4-10 声明二维数组
// 声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素
var array [4][2]int
// 使用数组字面量来声明并初始化一个二维整型数组
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化外层数组中索引为 1 个和 3 的元素
array := [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化外层数组和内层数组的单个元素
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
图 4-8 展示了代码清单 4-10 中声明的二维数组在每次声明并初始化后包含的值。
```

![图 4-8 二维数组及其外层数组和内层数组的值  ](images\图 4-8 二维数组及其外层数组和内层数组的值.jpg)

只要类型一致，就可以将多维数组互相赋值，如代码清单 4-12 所示。多维数组的类型包括每 一维度的长度以及最终存储在元素中的数据的类型。  







###4.1.5 在函数间传递数组 59

根据内存和性能来看，在**函数间传递数组**是一个**开销很大**的操作。在函数之间传递变量时， 总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会**完整复 制，并传递给函数**  .

```
代码清单 4-14 使用值传递
// 声明一个需要 8 MB 的
var array [1e6]int
// 将数组传递给函数 foo
foo(array)
// 函数 foo 接受一个 100 万个整型值的数组
func foo(array [1e6]int) {
...
}

```

每次函数 foo 被调用时，必须在栈上分配 8 MB 的内存。之后，整个数组的值（8 MB 的内
存）被复制到刚分配的内存里。虽然 Go 语言自己会处理这个复制操作，不过还有一种更好且更
有效的方法来处理这个操作。可以只传入指向数组的指针，这样只需要复制 8 字节的数据而不是
8 MB 的内存数据到栈上，如代码清单 4-15 所示。



```go
代码清单 4-15 使用指针在函数间传递大数组
// 分配一个需要 8 MB 的数组
var array [1e6]int
// 将数组的地址传递给函数 foo
foo(&array)
// 函数 foo 接受一个指向 100 万个整型值的数组的指针
func foo(array *[1e6]int) {
...
}
```

    这次函数 foo 接受一个指向 100 万个整型值的数组的指针。现在将数组的地址传入函数， 只需要在栈上分配 8 字节的内存给指针就可以。 

    这个操作会更有效地利用内存，性能也更好。不过要意识到，因为现在传递的是指针， 所以如果改变指针指向的值，会改变共享的内存。如你所见，使用切片能更好地处理这类共 享问题。  

##4.2 切片的内部实现和基础功能 60

切片是一种数据结构，这种数据结构便于使用和管理数据集合。

切片是围绕动态数组的概念 构建的，可以按需自动增长和缩小。

切片的动态增长是通过内置函数 append 来实现的。这个函 数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的 底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处  

###4.2.1 内部实现 60

	切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。切片有 3 个字段 的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数据（见图 4-9）。

	 这 3 个字段分别是**指向底层数组的指针**、切片访问的元素的个数（即**长度**）和切片允许增长 到的元素个数（即**容量**）。后面会进一步讲解长度和容量的区别。  

- [ ] 

![图 4-9 切片内部实现：底层数组  ](images\图 4-9 切片内部实现：底层数组.jpg)

###4.2.2 创建和初始化 61

#### 1. make 和切片字面量  

```go
代码清单 4-16 使用长度声明一个字符串切片
// 创建一个字符串切片
// 其长度和容量都是 5 个元素
slice := make([]string, 5)
如果只指定长度，那么切片的容量和长度相等。也可以分别指定长度和容量，如代码清单 4-17
所示。
代码清单 4-17 使用长度和容量声明整型切片
// 创建一个整型切片
// 其长度为 3 个元素，容量为 5 个元素
slice := make([]int, 3, 5)
分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能
访问所有的数组元素。图 4-9 描述了代码清单 4-17 里声明的整型切片在初始化并存入一些值后的
样子。
```

不允许创建容量小于长度的切片，如代码清单 4-18 所示  

```go
代码清单 4-18 容量小于长度的切片会在编译时报错
// 创建一个整型切片
// 使其长度大于容量
slice := make([]int, 5, 3)

Compiler Error:
len larger than cap in make([]int)
```



	另一种常用的创建切片的方法是使用切片字面量，如代码清单 4-19 所示。这种方法和创建 数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的 个数确定。  

```go
代码清单 4-19 通过切片字面量来声明切片
// 创建字符串切片
// 其长度和容量都是 5 个元素
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}
// 创建一个整型切片
// 其长度和容量都是 3 个元素
slice := []int{10, 20, 30}
```

当使用切片字面量时，可以设置初始长度和容量。要做的就是在初始化时给出所需的长 度和容量作为索引。代码清单 4-20 中的语法展示了如何创建长度和容量都是 100 个元素的 切片。  

```go
代码清单 4-20 使用索引声明切片
// 创建字符串切片
// 使用空字符串初始化第 100 个元素
slice := []string{99: ""}
```



	**记住，如果在[]运算符里指定了一个值，那么创建的就是数组而不是切片**。只有不指定值 的时候，才会创建切片，如代码清单 4-21 所示。  

```
代码清单 4-21 声明数组和声明切片的不同
// 创建有 3 个元素的整型数组
array := [3]int{10, 20, 30}
// 创建长度和容量都是 3 的整型切片
slice := []int{10, 20, 30}
```



#### 2.nil 和空切片  

有时，程序可能需要声明一个值为 nil 的切片（也称 nil 切片）。只要在声明时不做任何初化，就会创建一个 nil 切片，如代码清单 4-22 所示  

```go
代码清单 4-22 创建 nil 切片
// 创建 nil 整型切片
var slice []int
```

![图 4-10 nil 切片的表示  ](images\图 4-10 nil 切片的表示.jpg)



```go
代码清单 4-23 声明空切片
// 使用 make 创建空的整型切片
slice := make([]int, 0)
// 使用切片字面量创建空的整型切片
slice := []int{}
```

空切片在底层数组包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用， 例如，数据库查询返回 0 个查询结果时（见图 4-11）。  

![图 4-11 空切片的表示  ](images\图 4-11 空切片的表示.jpg)

不管是使用 nil 切片还是空切片，对其调用内置函数 append、 len 和 cap 的效果都是 一样的。  

###4.2.3 使用切片 63

#### 1． 赋值和切片  

通过 `a[start:end]` 这样的语法创建了一个从 `a[start]` 到 `a[end -1]` 的切片， start从0开始，

```go
代码清单 4-25 使用切片创建切片
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新切片
// 其长度为 2 个元素，容量为 4 个元素
newSlice := slice[1:3]

```

![图 4-12 共享同一底层数组的两个切片  ](images\图 4-12 共享同一底层数组的两个切片.jpg)

代码清单 4-26 如何计算长度和容量 

对底层数组容量是 k 的切片 ，slice[i:j]来说 

**长度: j - i** 

**容量: k - i**  

```sh
对 newSlice 应用这个公式就能得到代码清单 4-27 所示的数字。
代码清单 4-27 计算新的长度和容量
对底层数组容量是 5 的切片 slice[1:3]来说
长度: 3 - 1 = 2
容量: 5 - 1 = 4
```

	可以用另一种方法来描述这几个值。第一个值表示新切片开始的元素的索引位置，这个例子 中是 1。第二个值表示开始的索引位置（1），加上希望包含的元素的个数（2）， 1+2 的结果是 3， 所以第二个值就是 3。容量是该与切片相关联的所有元素的数量。

	 需要记住的是，现在两个切片共享同一个底层数组。如果一个切片修改了该底层数组的共享 部分，另一个切片也能感知到，如代码清单 4-28 所示  

```go
代码清单 4-29 表示索引越界的语言运行时错误
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新切片
// 其长度为 2 个元素，容量为 4 个元素
newSlice := slice[1:3]
// 修改 newSlice 索引为 3 的元素
// 这个元素对于 newSlice 来说并不存在
newSlice[3] = 45
Runtime Exception:
panic: runtime error: index out of range
```

	切片有额外的容量是很好，但是如果不能把这些容量合并到切片的长度里，这些容量就没有 用处。好在可以用 Go 语言的内置函数 append 来做这种合并很容易。  



####2． 切片增长  

	函数 append 总是会增加新切片的长 度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。  





#### 3． 创建切片时的 3 个索引  



#### 4． 迭代切片  





###4.2.4 多维切片 74



###4.2.5 在函数间传递切片 75



##4.3 映射的内部实现和基础功能 76



###4.3.1 内部实现 76



###4.3.2 创建和初始化 78



###4.3.3 使用映射 79



###4.3.4 在函数间传递映射 81



##4.4 小结 82